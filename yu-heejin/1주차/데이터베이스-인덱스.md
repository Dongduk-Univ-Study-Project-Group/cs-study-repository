## 인덱스란?

- 인덱스는 데이터베이스에서 테이블의 검색 성능을 높여주는 방법이다.
    - 데이터 베이스 테이블에 대한 검색 성능의 속도를 높여주는 **자료구조**
- 특정 컬럼에 인덱스를 생성하면, **해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.**
- 관계형 데이터베이스에서는 B+Tree 구조로 된 index를 사용하여 검색 속도를 향상시킨다.
- 특히, select - where 구조의 쿼리처럼 특정 데이터를 찾을 때 빠른 속도로 검색할 수 있게 도와준다.
- 인덱스가 생성되었다면, 쿼리문에 인덱스 생성 컬럼을 where 조건으로 거는 등의 작업을 하면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수 있다.
    - 아래 그림과 같이 인덱스를 타게 되고, 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작하여 검색 속도의 향상을 가져올 수 있다.
        
        ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06849388-002f-4c80-ac29-cb79c8d05940/Untitled.png)
        
- 또한, 인덱스 생성 시 **데이터를 오름차순으로 정렬하기 때문에 정렬된 주소체계라고 표현**할 수 있다.

### 인덱스의 구조

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c98e595-4fee-46ad-a2dd-4e87d834e09a/Untitled.png)

- 인덱스에는 다양한 유형이 있지만, 가장 많이 사용하는 구조는 B Tree이다.
    - 특히, B Tree 인덱스 중에서도 가장 많이 사용되는 것은 B*Tree와 B+Tree 구조가 가장 많이 사용된다.
- B*Tree 인덱스는 대부분의 DBMS, 특히 오라클에서 중점적으로 사용하고 있는 가장 보편적인 인덱스이다.
- 구조는 Root, Branch, Leaf로 구성되는 계층적 구조를 가지고 있다.
- 특정 컬럼에 인덱스를 생성하는 순간 컬럼의 값들을 정렬하는데, **오라클 서버에서 풀 스캔보다 인덱스 스캔이 유리하다고 판단되었을 때 생성한 인덱스의 정렬 순서가 중간쯤 되는 데이터를 뿌리에 해당하는 ROOT 블록으로 지정한다.**
- ROOT 블록을 기준으로 가지가 되는 BRANCH 블록을 정의하며, 마지막으로 잎에 해당하는 **LEAF 블록에 인덱스의 키가 되는 데이터와 데이터의 물리적 주소 정보인 ROWID를 저장한다.**

## 인덱스를 사용하는 이유

- 테이블의 데이터는 순서 없이 쌓이게 되므로 특정 조건의 데이터를 찾으려면 테이블의 모든 데이터에 접근하여 비교하는 과정이 필요하다. (full table scan)
- 하지만, 인덱스가 있는 경우 search-key가 정렬되어있기 때문에 조건 검색 시 속도가 빠르다.
- 만약 대량의 데이터를 가지고 있고, select-where 같은 특정 조건의 데이터를 찾을 때, 인덱스를 활용하여 빠르게 데이터를 가져올 수 있다.
    - 반대로, 데이터의 양이 많지 않다면 굳이 인덱스를 사용할 필요가 없다.

## 인덱스의 종류

### 클러스터형 인덱스 (Clustering index)

- 특정 컬럼을 기본키로 지정하면 자동으로 인덱스가 생성되고, 테이블 자체가 정렬된 인덱스가 된다. (컬럼을 기본키로 지정하면 테이블이 기본키를 정렬한다.)

### 보조 인덱스 (Secondary index)

- 별도의 공간에 인덱스를 생성한다. (create index 혹은 고유키를 지정하면 생성)

## 인덱스의 장단점

### 장점

- 빠른 검색 속도 향상
- 데이터들이 정렬되어 있기 때문에 조건 검색이라는 영역에서 큰 장점이 된다.
- 조건 검색 where 절의 효율성
    - 테이블을 만들고 안에 데이터가 쌓이게 되면 테이블의 레코드는 내부적으로 순서가 없이 뒤죽박죽 저장된다.
    - 이렇게 되면 **where 절에 특정 조건에 맞는 데이터들을 찾아낼 때도 레코드의 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야한다. → Full Table Scan**
    - 하지만, 인덱스 테이블 스캔 시 **인덱스 테이블은 데이터들이 정렬되어 저장되어있기 때문에 해당 조건에 맞는 데이터들을 빠르게 찾아낼 수 있다.**
- 정렬 ORDER BY 절의 효율성
    - 인덱스를 사용하면 order by에 의한 정렬 과정을 피할 수 있다.
    - **order by는 굉장히 부하가 많이 걸리는 작업이다.** 정렬과 동시에 1차적으로 메모리에서 정렬이 이루어지고 메모리보다 큰 작업이 필요하다면 디스크 IO도 추가적으로 발생되기 때문이다.
    - 하지만 인덱스를 사용하면 이미 정렬되어있기 때문에 가져오기만 하면 되므로 이러한 자원 소모를 피할 수 있다.
    - 디스트 IO: 우리가 데이터를 작성하고 변경할 적에 디스크, 즉 HDD에 저장되는 것을 말한다.
- MIN, MAX의 효율적인 처리
    - 데이터가 정렬되어있기 때문에 얻을 수 있는 장점이다.
    - MIN값과 MAX값을 레코드의 시작과 끝 값 한 건씩만 가져오면 되기 때문에 Full Table Scan으로 테이블을 모두 뒤져서 작업하는 것보다 훨씬 효율적으로 찾을 수 있다.

### 단점

- 추가 저장공간이 필요하다 (약 10%)
- insert, update, delete 등의 변동 사항이 있는 경우 성능이 저하된다. (DML 취약)
    - 데이터 변경 시 인덱스 테이블 내에 있는 값들을 다시 정렬해야한다.
    - 인덱스 테이블, 원본 테이블 두 군데에 데이터 수정 작업이 필요하다.
    - 정렬된 상태를 계속 유지시켜야하기 때문에, 레코드 내에 데이터 값이 바뀌는 부분이라면 악영향을 미친다.
    - 따라서 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다.
- 무조건 인덱스 스캔이 좋은 것은 아니다.
    - 인덱스는 테이블의 전체 데이터 중 10~15% 이하의 데이터를 처리하는 경우에만 효율적이고, 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다.
    - 즉, 1개의 데이터가 들어있는 테이블은 인덱스 스캔보단 풀 스캔이 빠르고, 100만개의 데이터가 들어있는 테이블이라면 인덱스 스캔이 유리하다.
- 속도 향상을 위해 인덱스를 많이 만드는 것은 좋지 않다.
    - 인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다.
    - 즉, 무턱대로 인덱스를 만들어서는 절대 안된다.
    - 문제가 발생할 때마다 인덱스를 생성하면서 인덱스가 쌓여가는 것은 하나의 쿼리문을 빠르게 만들 수는 있지만 전체적인 데이터베이스의 성능 부하를 초래한다.
    - 인덱스 생성보다는 **SQL문을 좀 더 효율적으로 짜는 방향**으로 가야한다.

## 인덱스를 어느 컬럼에 사용하는 것이 좋을까?

- 인덱스는 where 절에서 **자주 조회**하고, **수정 빈도가 낮으며** **데이터 중복이 적은 컬럼**을 선택하는 것이 좋다.
    - 생성된 인덱스를 가장 효율적으로 사용하려면 **데이터의 분포도는 최대한, 조건절의 호출 빈도는 자주 사용되는 컬럼**을 인덱스로 생성하는 것이 좋다.
    - **인덱스는 특정 컬럼을 기준으로 생성**하고, **기준이 된 컬럼으로 정렬된 인덱스 테이블이 생성된다.**
    - 이 기준 컬럼은 최대한 중복되지 않는 값이 좋다.
- join 조건으로 자주 사용되는 컬럼도 인덱스로 사용하면 좋다.
- 데이터의 양이 많을수록 인덱스 성능 향상이 커진다.
- 단, 한 테이블에 인덱스가 너무 많으면 데이터 수정 시 소요 시간이 커진다.
- 또한, 성별처럼 **데이터 중복이 높은 값은 인덱스를 생성하는 것이 큰 의미가 없다.**
    - 인덱스의 이점보다 추가 저장공간이나 데이터 수정에 대한 성능 저하가 더 크기 때문
- 가장 최선은 **PK로 인덱스**를 거는 것
    - 중복된 값이 없는 인덱스 테이블이 최적의 효율을 발생시킨다.
    
1. 조건절에 자주 등장하는 컬럼
2. 항상 = 으로 비교되는 컬럼
3. 중복되는 데이터가 최소한인 컬럼 (분포도가 좋은 컬럼)
4. ORDER BY 절에서 자주 사용되는 컬럼
5. JOIN 조건으로 자주 사용되는 컬럼

## 인덱스 관리

- 인덱스는 데이터 삭제 개념에서 인덱스를 사용하지 않기도 한다.
    - INSERT: 새로운 데이터에 대한 인덱스 추가
    - DELETE: 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업을 진행한다.
    - UPDATE: 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대해 인덱스를 추가한다.

## 참고 자료

- [https://daco2020.tistory.com/258?category=996087](https://daco2020.tistory.com/258?category=996087)
- [https://choicode.tistory.com/27](https://choicode.tistory.com/27)