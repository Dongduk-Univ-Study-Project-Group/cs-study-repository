> **TCP가 가상회선을 만들고 제거하는 과정에 대해서 묻는 질문**입니다. TCP를 공부하셨다면 이 정도는 알겠지 하고 묻는 문제고, 실제 면접자리에서는 보통 네트워크에 대해서 설명할 때, 직접 설명하는 편입니다.
> 

> TCP 3way handshake는 가상회선을 수립하는 단계입니다. 클라이언트는 서버에 요청을 전송할 수 있는지, 서버는 클라이언트에게 응답을 전송할 수 있는지 확인하는 과정입니다. SYN, ACK 패킷을 주고받으며, 임의의 난수로 SYN 플래그를 전송하고, ACK 플래그에는 1을 더한값을 전송합니다. 정확한 순서는 SYN(n) -> ACK(n + 1), SYN(m) -> ACK(m + 1) 순으로 일어납니다.
> 

> 왜 임의의 난수를 지정하느냐는 꼬리질문이 나올 수 있습니다. 기존 요청과 구분하기 위해서 정도로 알고있고, 그 이상은 생각해본적이 없네요.
> 

> TCP 4way handshake는 TCP연결을 해제하는 단계로, 클라이언트는 서버에게 연결해제를 통지하고 서버가 이를 확인하고 클라이언트에게 이를 받았음을 전송해주고 최종적으로 연결이 해제됩니다. 단, 서버에서 소켓이 닫혔다고 통지해도 클라이언트 측에서는 일정시간 대기하는데, 혹시나 패킷이 나중에 도착할 수 있기 때문입니다.
> 

---

## TCP 3-way Handshake

- TCP는 장치들 사이에 논리적인 접속을 성립하기 위해 3-way handshake를 사용한다.
- TCP/IP 프로토콜을 이용해 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 **상대방 컴퓨터와 사전에 세션을 수립하는 과정**
- 연결하고자 하는 두 장치 간의 논리적 접속을 성립하기 위해 사용하는 연결 확인 방식으로, 3번의 확인 과정을 거친다.

### 전송 데이터

1. Client → Server : TCP SYN
    1. SYN(synchronize sequence numbers): 연결 확인을 위해 보내는 무작위의 숫자 값
2. Server → Client : TCP SYN, ACK
    1. ACK(acknowledgements): 클라이언트 혹은 서버로부터 받은 SYN에 1을 더해 SYN을 잘 받았다는 의미
3. Client → Server : TCP ACK

### 역할

- 양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달이 시작되기 전에 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.
- 양쪽 모두 상대편에 대한 초기 순차일련번호를 얻을 수 있도록 한다.

### 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ad9d9fe2-49ae-4cd6-bdbe-e8748370006f/Untitled.png)

1. A클라이언트는 B서버에 접속을 요청하는 SYN 패킷을 보낸다.
    1. 이때, 클라이언트는 SYN을 보내고 SYN/ACK 응답을 기다리는 SYN_SENT 상태, 서버는 Wait for Client 상태가 된다.
2. B서버는 SYN 요청을 받고 A클라이언트에게 요청을 수락한다는 ACK와 SYN flag가 설정된 패킷을 발송하고, A가 다시 ACK으로 응답하길 기다린다.
    1. 이 때 서버는 SYN_RECEIVED 상태가 된다.
3. 클라이언트는 서버에게 ACK을 보내고, 이후 연결이 이루어지고 데이터가 오가게 된다.
    1. 이 때 서버의 상태는 ESTABLISHED 상태이다.

| 상태 | 설명 |
| --- | --- |
| CLOSED | 연결 수립을 시작하기 전의 기본 상태 (연결 없음) |
| LISTEN | 포트가 열린 상태로 연결 요청 대기 중 |
| SYN-SENT | SYN 요청을 한 상태 |
| SYN-RECEIVED | SYN 요청을 받고 상대방의 응답을 기다리는 중 |
| ESTABLISEHD | 연결의 수립이 완료된 상태, 서로 데이터를 교환할 수 있다. |

## 4-way Handshaking

- 3-way가 TCP의 연결을 초기화 할 때 사용한다면, **4-way는 세션을 종료하기 위해 수행되는 절차이다.**
- 가상 회선 연결을 해제할 때 주고 받는 확인 작업

### 과정

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9fb7e8be-4d18-4478-bab7-614daf5cfc74/Untitled.png)

1. 클라이언트가 연결을 종료하겠다는 FIN 플래그를 전송한다.
    1. 이 때 클라이언트는 FIN-WAIT 상태가 된다.
2. 서버는 FIN 플래그를 받고, 확인 메세지 ACK를 보낸 후 자신의 통신이 끝날 때까지 기다린다.
    1. 이 때 서버는 CLOSE_WAIT 상태이다.
3. 연결을 종료할 준비가 되면, 연결 해지를 위한 준비가 되었음을 알리기 위해 클라이언트에게 FIN 플래그를 전송한다.
    1. 서버의 상태는 LAST-ACK 상태이다.
4. 클라이언트는 해지준비가 되었다는 ACK을 확인했다는 메세지를 보낸다.
    1. 클라이언트의 상태가 FIN-WAIT → TIME-WAIT 상태가 된다.

| CLOSE | 연결 수립을 시작하기 전의 기본 상태 (연결 없음) |
| --- | --- |
| ESTABLISHED | 연결의 수립이 완료된 상태, 서로 데이터를 교환할 수 있다. |
| CLOSE-WAIT | 상대방의 FIN(종료 요청)을 받은 상태. 상대방 FIN에 대한 ACK를 보내고 애플리케이션에 종료를 알린다. |
| LAST-ACK | CLOSE-WAIT 상태를 처리 후 자신의 FIN요청을 보낸 후 FIN에 대한 ACK를 기다리는 상태. |
| FIN-WAIT-1 | 자신이 보낸 FIN에 대한 ACK를 기다리거나 상대방의 FIN을 기다린다. |
| FIN-WAIT-2 | 자신이 보낸 FIN에 대한 ACK를 받았고 상대방의 FIN을 기다린다. |
| CLOSING | 상대방의 FIN에 ACK를 보냈지만 자신의 FIN에 대한 ACK를 못받은 상태 |
| TIME-WAIT | 모든 FIN에 대한 ACK를 받고 연결 종료가 완료된 상태. 새 연결과 겹치지 않도록 일정 시간 동안 기다린 후 CLOSED로 전이한다. |

> 만약 서버에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN 패킷보다 늦게 도착하는 상황이 발생한다면?
> 
- 클라이언트에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면 이 패킷은 drop되며 데이터는 유실된다.
- 클라이언트는 이러한 현상에 대비해 서버로부터 FIN을 수신하더라도 일정시간 동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치는데, 이 과정을 TIME_WAIT라고 한다.
- 일정 시간이 지나면 세션을 만료하고 연결을 종료시키며 CLOSE 상태로 변화한다.

---

## [추가] SYN의 값에 무작위 수를 사용하는 이유?

- Connection을 맺을 때 사용하는 포트는 유한 범위 내에서 사용하고, 시간이 지남에 따라 재사용된다.
    - 따라서 두 통신 호스트가 과거에 사용된 포트 번호 쌍을 사용할 가능성이 존재한다.
- 서버 측에서 패킷의 SYN을 보고 패킷을 구분하는데, 난수가 아닌 순차적인 숫자가 전송된다면 이전의 connection으로부터 오는 패킷으로 인식할 수 있어 이러한 문제 발생 가능성을 줄이기 위해 ISN을 무작위 난수로 사용하는 것
    - ISN(Initial Sequence Numbers): 클라이언트와 서버가 각각 처음으로 생성한 SYN

## Time-Wait

- 먼저 연결을 끊는 쪽에 생성되는 소켓으로, 혹시 모를 패킷 전송 실패에 대비하기 위해 존재하는 소캣
- time-wait이 없으면 패킷의 손실이 발생하거나 통신자 간 연결 해제가 제대로 이루어지지 않을 수 있다.

## 참고 자료

- [https://bangu4.tistory.com/74](https://bangu4.tistory.com/74)
- [https://seongonion.tistory.com/74](https://seongonion.tistory.com/74)